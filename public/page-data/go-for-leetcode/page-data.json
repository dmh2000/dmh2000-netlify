{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/go-for-leetcode","result":{"data":{"post":{"__typename":"MdxPost","slug":"/go-for-leetcode","title":"A Good Way to Go (Why I Use Go for LeetCode)","date":"18.05.2020","tags":null,"description":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"A Good Way to Go (Why I Use Go for LeetCode)\",\n  \"date\": \"2020-05-18T00:00:00.000Z\",\n  \"slug\": \"/go-for-leetcode\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Why I Use Go for Leetcode\"), mdx(\"p\", null, \"I am not a LeetCode expert, although I have a few years of coding experience.\\nI have about 80 accepted solutions, mostly easy. I do them for fun and learning.\\nDue to early mistakes in the process, my acceptance rate is only 39%.\\nThat's terrible and it is because I would 'Submit' before I was ready.\\nInitially I used C++ for solving the problems but lately have\\nswitched to using Go. I find that using Go is very efficient. \"), mdx(\"p\", null, \"In my initial forays into LeetCode I used C++ because I was most familiar with it. Here are a few pros and cons (my opinion) for using C++:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pro C++\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"its a statically typed language. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the standard library has extensive support for most of the data structures you will ever need. \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"with the exception of the LeetCode Tree.\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Con C++\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"verbose\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"sometimes complicated syntax\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"edit-compile-run cycle has friction\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"even in Visual Studio, the cycle takes a flow-breaking delay.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"difficult to run snippets without some setup and without having to change it to run a different one\")))), mdx(\"h4\", null, \"My Process\"), mdx(\"p\", null, \"First, let me outline a process for solving LeetCode problems\\nthat I believe lead to better submission outcomes. I define\\na good submission outcome to be one that works on the first\\n'Submit'. An ok one is two or three 'Submit's. Worst is a long string\\nof submit errors because I lost discipline and was just trying things.\\nThis kills your submission stats. If that matters, and its kind of funny that\\nit matters to me when no one else will ever care about or even see my stats. People\\nare sometimes (usually?) their own harshest judge.\\nMost errors on those submissions could have be avoided with a good process.\"), mdx(\"p\", null, \"This may not lead to  getting to a working submission the quickest,\\nbut it will help your submission stats. No one will know if you\\niterated on a problem 100 times before getting it to work. \"), mdx(\"p\", null, \" (I exclude the geniuses who can just read the problem, visualize the code, type it in and submit)\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Understand the problem\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sometimes I have done a cursory look at the problem, thought 'ok that's easy'and had mistakes because, well, I didn't actually know what the solution was actually supposed to do. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"be clear what the specs are for the inputs, like integer range, empty inputs ('[]'), length of allowed test cases. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if a problem specifies it might have 10^8 items in a test case (I've seen that) you can be sure an N^2 solution won't pass.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"on the other hand, just like its recommended for coding interviews, consider implementing a brute force solution first. You can run your test cases locally to see if your understanding of the problem makes sense. Then think about improving the O(?).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"work it out on paper as if you were whiteboarding\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Implement your solution offline\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"with the right tooling you can get to a working solution much faster than flailing on the LeetCode environment.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"by working offline, you can experiment efficiently and build up a solution incrementally. \"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Test locally all the given test cases and any others you can think of that would catch corner cases.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"avoid all that  'pending', 'speedup', 'judging' wait.wait.wait...\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"of course testing catches mistakes. running the tests offline ensure you don't accidentally submit a non-working solution.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"using an offline test fixture, you can create and execute an array of tests and run them all to detect regressions. You can only do one at a time on the LeetCode environment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you have good tooling you can get this done efficiently.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When you think you have a solution, paste your working offline code into the LeetCode editor.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IF you make any change to your code right in the LeetCode editor, be sure to do a 'Run Code' pass so you don't get a submission fail due to a syntax error or typo.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Run the same testcases on the LeetCode environment before submitting.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be sure your use the same test cases. Reenter the tests using the custom test case option, just in case you had a typo or mistake in your offline test cases.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Finally, when everything looks good, hit 'Submit'. \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you keep up your discipline, most times it will fly\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I never submit until my offline tests all work. if my submissions fail on the first try, its usually because there is a test case I didn't think of. So go back offline, implement the test case and try again.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the second reason my submissions might fail on a first try is a Timeout. Typically that happens if I do a quick naive solution that is N^2 (test all items in array A against all items in Array B) or worse N! (permutations and combinations).\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Finally, when I get stuck after spending an hour on it, I go ahead and Google for a solution. \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Is LeetCode testing than you can crap out the Knuth-Morris-Pratt algorithm from scratch? JH Morris actually did that way back around 1970, but I expect he spent more than a couple of hours on it. Maybe not?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I treat LeetCode as a learning method so at some point a problem will be too tough. But when when you do use a known solution, work through the theory and try to implement it yourself. Don't copy/paste someone else's code. \"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Finally, consider keeping your solutions in Github or the like. You may want to refer back someday.\")), mdx(\"p\", null, \"One thing I have heard of is that some top experts actually compose a proof of their algorithm before submitting it. Those guys are simply geniuses. None of this applies to those folks.\"), mdx(\"h4\", null, \"Why Go?\"), mdx(\"p\", null, \"The Go language has some warts and there are credible arguments about it. Just google 'is Go any good'.   I'm not here to argue one way or the other, at least in general. \"), mdx(\"p\", null, \"However, for LeetCode use, I find it worthy.  Let me say why. But first some recommendations for what helps in a selection of language platform for LeetCode. \"), mdx(\"p\", null, \"You want least-friction tooling.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You want your edit-compile-run or edit-run cycle to be a one-click affair\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Avoiding a compile cycle reduces friction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dynamic languages like JavaScript and Python decrease friction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"verbose languages like C++ and Java increase friction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"long compile times increase friction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"its nice if you can edit..run right from your edit environment. Most tooling these days allows that. Some better than others.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"being able to run bits of code independently without having to hack a main function. Really helps with testing.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"having platform native test-fixture support is a win\")), mdx(\"p\", null, \"Your language and its libraries for the LeetCode platform need to provide a few things so you don't have to reinvent the wheel. Of course\\nif your language doesn't have these, you can build them yourself and keep them handy. But\\nfor those of us who are lazy, its nice if batteries are included:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dynamic arrays\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"needed all the time for LeetCode problems\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"has push front/back, pop front/back and indexed access\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Python lists, JavaScript arrays, C++ vectors, etc\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be inefficient if you have a lot of resizing, pushing, popping, slicing, etc. consider a linked list if you don't need indexed access.\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"linked lists \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for efficient append/prepend and remove in the middle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you need a queue or stack\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"hash table \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"unordered key/value store\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"needed all the time\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"less important nice-to-have\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"heap \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"generics\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"to make type safe collections\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"functional-ness, avoids errors due to unintended mutations\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Map,Reduce,Filter\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"non-mutability\")))), mdx(\"h5\", null, \"LeetCode Trees\"), mdx(\"p\", null, \"One thing LeetCode uses A LOT is a binary tree with their own node definition.\\nIt can really help if you go ahead and create an implementation of building and\\ntraversing a LeetCode TreeNode tree of your own. If you don't have this, you can't test offline.\\nYou need some code that lets you build a LeetCode TreeNode tree from an array of input to be able to test.\\nThe appendix below has an implementation that I use.\"), mdx(\"h2\", null, \"Using Go with LeetCode\"), mdx(\"p\", null, \"After a break of not doing any LeetCode for a year, I jumped back in. I did this because I had started learning Go and\\nI wanted to practice Go coding beyond the tutorials. I found that using Go with Visual Studio Code was a gigantic win\\napplied to LeetCode. There is a reason VS Code has taken over the world. \"), mdx(\"p\", null, \"Here are some pros and cons. Not necessarily in comparison to other languages.\\nJust in terms of Go with LeetCode. Here is a link that discusses the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/\"\n  }), \"the good, the bad, and the ugly\")), mdx(\"p\", null, \"Pros of Go (for LeetCode):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"statically typed and type inference\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"supported by VS Code\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"VS Code makes typos and type mismatch obvious without having to run first.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for LeetCode purposes, statically typed languages prevent errors introduced by typos that would allow a dynamic language program to run but give unexpected results. At least, that's my opinion. A Python or JavaScript expert might disagree. It does introduce a bit of friction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you are in a hurry, you can use := to avoid extra work declaring variable types while maintaining static typing.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mostly familiar structure\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you are used to C structured languages\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"kind of simple for LeetCode purposes\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"going through the official golang.org tutorial is enough to learn it for LeetCode. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"once you figure out a couple of things.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"slices\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"method sets\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"not verbose\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"looks kind of like C++ with about half the keyboard clicking.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \":= lets you skip some declarations with type safety\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"garbage collection\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no need to manage memory as in C/C++\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"has all the data structures listed above in its standard library.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dynamic arrays : slice\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"hash table : map\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"included but not type safe due to lack of generics.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"doubly linked list : container/list\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"heap : colelctions/heap\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"not included\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"balanced trees : NO, doesn't have. probably don't need most of the time.\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"native test framework\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"very easy to setup and run, doesn't require a main fixture. just write snippets using the test framework.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"easy to run an entire test suite, automatically finds all the tests based on file and fucntion naming conventions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"with VS code its easy to run individual test snippets with a single click.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the appendix has an example of what the Go test framework lets you do\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"VS Code Integration\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"static typing and inference identifies many errors immediately\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"using the golang test framework and VSCode makes it frictionless to run test cases against the LeetCode problems.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"instant feedback for syntax errors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"builds are instantaneous for the size of LeetCode problems.\")))), mdx(\"p\", null, \"Cons of Go (For LeetCode):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no Generics\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"really hurts in some situations\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \":= can shadow variables, creating weird results\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"is it any better than other languages? yes, no, maybe. it depends.\")), mdx(\"p\", null, \"Other stuff:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"does learning Go do you any good \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for jobs? maybe but probably not. it might be a plus on a resume (if  you can back it up)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for expanding your knowledge in general, yea\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if it takes away time from relevant platforms?\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you are a C,C++,Java,JavaScript,C# programmer you will find your fingers doing things wrong in Go\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"inserting extra parens\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"defining types in \", \"[type][variable name]\", \" order. go is \", \"[name][type]\", \" order.\")))), mdx(\"h4\", null, \"Conclusion\"), mdx(\"p\", null, \"I contend that for LeetCode use, Go the language is good enough. Not verbose, almost feels like a dynamic\\nlanguage but with static typing. Go has most of what you need. And with VSCode you get a very frictionless\\ncoding experience.\"), mdx(\"h4\", null, \"Appendix\"), mdx(\"pre\", null), mdx(\"h5\", null, \"1. LeetCode Tree Utility\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"// TreeNode ...\\ntype TreeNode struct {\\n    Val   int\\n    Left  *TreeNode\\n    Right *TreeNode\\n}\\n\\nfunc insertLevelOrder(arr []int, root *TreeNode, i int, n int) *TreeNode {\\n    // Base case for recursion\\n    if i >= n {\\n        return root\\n    }\\n\\n    // NOTE : for empty nodes leetcode will \\n    // use 'null' in the test spec [1,2,null,3,4]\\n    // This implementation substitutes -2147483648 for null\\n    // so an input slice would be [1,2,-2147483648,3,4] instead\\n    // terms with -2147483648 will be nil in the \\n    // constructed tree. since this whole implementation is only used locally\\n    // it doesn't affect your solution.\\n    if arr[i] == -2147483648 {\\n        return nil\\n    }\\n\\n    root = newNode(arr[i])\\n\\n    // insert left child\\n    root.Left = insertLevelOrder(arr, root.Left, 2*i+1, n)\\n\\n    // insert right child\\n    root.Right = insertLevelOrder(arr, root.Right, 2*i+2, n)\\n\\n    return root\\n}\\n\\nfunc inOrderF(node *TreeNode, f func(n *TreeNode)) {\\n    if node != nil {\\n        inOrder(node.Left)\\n        // Visit\\n        f(node)\\n        inOrder(node.Right)\\n    }\\n}\\n\\nfunc preOrderF(node *TreeNode, f func(n *TreeNode)) {\\n    if node != nil {\\n        // Visit\\n        f(node)\\n        preOrder(node.Left)\\n        preOrder(node.Right)\\n    }\\n}\\n\\nfunc postOrderF(node *TreeNode, f func(n *TreeNode)) {\\n    if node != nil {\\n        postOrder(node.Left)\\n        postOrder(node.Right)\\n        // Visit\\n        f(node)\\n    }\\n}\\n\\nfunc newNode(v int) *TreeNode {\\n    return &TreeNode{Val: v, Left: nil, Right: nil}\\n}\\n\\nfunc buildLeetCodeTree(a []int) *TreeNode {\\n    var root *TreeNode\\n\\n    root = insertLevelOrder(a, root, 0, len(a))\\n\\n    return root\\n}\\n\\n/*\\n   inserts in LeetCode level order, not sorted order   \\n   \\n   input: \\n     a := []int{1, 2, 3, 4, 5}\\n\\n   tree structure:\\n    /*\\n               1\\n             /    \\\\ \\n            /      \\\\\\n           2        3\\n         /  \\\\\\n        4    5\\n\\n    */\\n*/\\n\")), mdx(\"pre\", null), mdx(\"h5\", null, \"1. VSCode + Go Test fixture\"), mdx(\"p\", null, \"Go has a very simple native test fixture that is easy to use and fits right in\\nfor writing and testing snippets without a lot of setup. If your code is in\\ntree.go, create a file tree_test.go, import \\\"testing\\\" and implement your tests.\\nRead all about it \", \"[here}(https://golang.org/pkg/testing/]\"), mdx(\"p\", null, \"Here's an example of what it looks like and how it shows up in VSCode.\\nThe cool thing is you can change a snippet then test it by clicking right\\non the test file. (VSCode adds the run test | debug test buttons. They aren't in the source code)\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"960px\"\n    }\n  }), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"77.08333333333333%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAByLBAf//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAMAAwAAAAAAAAAAAAAAAAARQQEQIf/aAAgBAQABPyHqpBiyNTX/2gAMAwEAAgADAAAAEMMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBABAQACAgMAAAAAAAAAAAAAAREAIRBBMVFx/9oACAEBAAE/EE2T6mBaRY+bild4Igd9XNCIvvj/2Q==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"VSCode + Go Test\",\n    \"title\": \"VSCode + Go Test\",\n    \"src\": \"/static/0372c48323b4238e157741d1d0122fac/18e3b/gotest.jpg\",\n    \"srcSet\": [\"/static/0372c48323b4238e157741d1d0122fac/46946/gotest.jpg 240w\", \"/static/0372c48323b4238e157741d1d0122fac/55489/gotest.jpg 480w\", \"/static/0372c48323b4238e157741d1d0122fac/18e3b/gotest.jpg 960w\", \"/static/0372c48323b4238e157741d1d0122fac/60e21/gotest.jpg 1440w\", \"/static/0372c48323b4238e157741d1d0122fac/d8509/gotest.jpg 1817w\"],\n    \"sizes\": \"(max-width: 960px) 100vw, 960px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Why I Use Go for Leetcode I am not a LeetCode expert, although I have a few years of coding experience. \nI have about 80 accepted solutions…","timeToRead":8,"banner":null}},"pageContext":{"slug":"/go-for-leetcode","formatString":"DD.MM.YYYY"}}}